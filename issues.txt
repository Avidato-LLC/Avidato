TITLE: Setup: Integrate Prisma and Connect to Database
BODY:
**Goal:** Establish the database layer for the application.
**Key Steps:**
1. Install Prisma CLI (`prisma`) and Prisma Client (`@prisma/client`).
2. Initialize Prisma with `npx prisma init --datasource-provider postgresql`.
3. Configure the `schema.prisma` file with the database connection URL (using an environment variable).
4. Create the initial data models required for Next-Auth (User, Account, Session, VerificationToken).
5. Run the initial migration with `npx prisma migrate dev --name init`.
6. Verify the connection to the database is successful.
LABELS: database, backend, setup
---
TITLE: Feat(Auth): Configure Next-Auth with Prisma Adapter
BODY:
**Goal:** Integrate Next-Auth with the Prisma database schema.
**Dependencies:** Issue #3
**Key Steps:**
1. Install Next-Auth (`next-auth`) and the Prisma Adapter (`@next-auth/prisma-adapter`).
2. Create the dynamic API route handler at `src/app/api/auth/[...nextauth]/route.ts`.
3. Configure the `authOptions` with a credentials provider (for email/password) and link the Prisma Adapter.
4. Ensure the `User`, `Account`, `Session`, and `VerificationToken` models in `schema.prisma` match Next-Auth requirements exactly.
5. Set up the `NEXTAUTH_SECRET` and `NEXTAUTH_URL` environment variables.
LABELS: auth, backend, feature
---
TITLE: Feat(Auth): Implement Session & Protected Middleware
BODY:
**Goal:** Protect application routes and ensure only authenticated users can access the dashboard.
**Dependencies:** Issue #4
**Key Steps:**
1. Create a `middleware.ts` file at the root of the `src/` directory.
2. The middleware should check for a valid user session on all routes matching `/dashboard/:path*`.
3. If no session exists, the user should be redirected to the `/login` page.
4. Public routes (like `/`, `/login`, `/signup`) should remain accessible.
LABELS: auth, backend, feature
---
TITLE: UI(Auth): Create Login and Signup Pages
BODY:
**Goal:** Build the frontend forms for user authentication.
**Key Steps:**
1. Create a route and page for `/login`.
2. Create a route and page for `/signup`.
3. Each page should contain a form with fields for "Email" and "Password".
4. Forms should have a "Submit" button.
5. Basic styling should adhere to the project's theme. Functionality will be added in a separate issue.
LABELS: ui, auth, feature
---
TITLE: Feat(Auth): Create Server Actions for Signup/Login
BODY:
**Goal:** Connect the authentication UI to the backend logic.
**Dependencies:** Issue #4, Issue #6
**Key Steps:**
1. Create a `signup` server action that takes form data, hashes the password (using `bcrypt`), and creates a new user in the database via Prisma.
2. Create a `login` server action that uses Next-Auth's `signIn` function with the "credentials" provider.
3. Hook up the forms on the `/signup` and `/login` pages to call these server actions on submit.
4. Implement basic error handling and redirects upon success/failure.
LABELS: auth, backend, feature
---
TITLE: UI(Dashboard): Create Main Dashboard Layout
BODY:
**Goal:** Build the main authenticated application shell.
**Key Steps:**
1. Create a new layout file for the `/dashboard` route group.
2. This layout should include a persistent sidebar for navigation and a main content area.
3. The sidebar should contain links (placeholders for now) for "Dashboard", "Students", and "Settings".
4. Include a user profile/logout button in the sidebar or a top header.
5. This layout must be protected by the middleware from Issue #5.
LABELS: ui, feature
---
TITLE: UI(Students): Create "Add Student" Page and Form
BODY:
**Goal:** Create the user interface for adding a new student to a tutor's roster.
**Key Steps:**
1. Create a page at `/dashboard/students/new`.
2. Build a form with fields for the student's name, email, language being studied, proficiency level (e.g., A1, A2, B1), and learning goals.
3. Style the form according to the application's theme.
LABELS: ui, students, feature
---
TITLE: Feat(Students): Create Server Action to Add Student
BODY:
**Goal:** Implement the backend logic to save a new student to the database.
**Dependencies:** Issue #9
**Key Steps:**
1. Update the `schema.prisma` file with a `Student` model. Remember to link it to the `User` model (a tutor has many students).
2. Create a server action that accepts the student form data.
3. The action should validate the input and create a new `Student` record in the database using Prisma.
4. After successful creation, it should redirect the user to the main students list page (`/dashboard/students`).
LABELS: backend, students, feature
---
TITLE: Feat(Students): Display List of All Students
BODY:
**Goal:** Create a page where the tutor can see all their students.
**Key Steps:**
1. Create a page at `/dashboard/students`.
2. Fetch the list of students associated with the currently logged-in user from the database.
3. Display the students in a list or card format, showing key information like name and language.
4. Each student item should link to their individual dynamic page (e.g., `/dashboard/students/[studentId]`).
LABELS: ui, backend, students, feature
---
TITLE: Feat(Students): Create Dynamic Page for Student
BODY:
**Goal:** Create a detail page for a single student.
**Key Steps:**
1. Create a dynamic route at `/dashboard/students/[studentId]`.
2. This page should fetch and display all details for the specified student.
3. It should also serve as the hub for viewing that student's generated course outlines and lessons (to be implemented later).
4. Include "Edit" and "Archive" buttons on this page.
LABELS: ui, backend, students, feature
---
TITLE: UI(Students): Create "Edit Student" Page
BODY:
**Goal:** Create the UI for updating an existing student's information.
**Dependencies:** Issue #12
**Key Steps:**
1. Create a dynamic route at `/dashboard/students/[studentId]/edit`.
2. The page should fetch the existing student's data and pre-populate the form fields.
3. The form should be identical to the "Add Student" form but for editing purposes.
LABELS: ui, students, feature
---
TITLE: Feat(Students): Create Server Action to Update Student
BODY:
**Goal:** Implement the backend logic to update a student's record.
**Dependencies:** Issue #13
**Key Steps:**
1. Create a server action that takes the updated form data and the student's ID.
2. The action should validate the data and use `prisma.student.update` to save the changes.
3. Upon success, redirect back to the student's detail page.
LABELS: backend, students, feature
---
TITLE: Feat(Students): Create Server Action to Archive Student
BODY:
**Goal:** Implement logic to soft-delete or archive a student.
**Key Steps:**
1. Add an `isArchived` boolean field (or a `status` enum) to the `Student` model in `schema.prisma`.
2. Create a server action that takes a student's ID.
3. The action will set the `isArchived` flag to `true` instead of deleting the record.
4. Archived students should be filtered out from the main student list by default.
LABELS: backend, students, feature
---
TITLE: UI(Lessons): Display Generated Lessons in Dashboard
BODY:
**Goal:** Build the UI on a student's page to list their generated lessons.
**Key Steps:**
1. On the dynamic student page (`/dashboard/students/[studentId]`), create a section to display course outlines and lessons.
2. Lessons should be displayed in a list, showing the lesson title and generation date.
3. Each lesson should have a button to "View" and a "Share" icon.
4. Include a prominent "Generate New Lesson Plan" button.
LABELS: ui, lessons, ai, feature
---
TITLE: Feat(AI): Generate Course Outlines via Server Action
BODY:
**Goal:** Integrate with the Google Gemini API to generate a 10-lesson course outline.
**Key Steps:**
1. Set up the Google Gemini API client.
2. Create a new server action that takes a student's profile (goals, proficiency) as input.
3. Construct a detailed prompt for the Gemini 1.5 Pro model, asking it to generate a structured 10-lesson course outline in JSON format.
4. The action will call the API, parse the response, and save the outline to the database, linked to the student.
LABELS: backend, ai, feature
---
TITLE: Feat(AI): Generate Detailed Lesson Plans via Server Action
BODY:
**Goal:** Use the Gemini API to expand a course outline topic into a full lesson plan.
**Dependencies:** Issue #17
**Key Steps:**
1. Create a server action that takes a student's profile and a specific lesson topic (from the outline).
2. Construct a complex prompt instructing the AI to generate a detailed lesson plan with specific sections: Warm-Up, Vocabulary, Main Activity, Practice, and Cool-Down. The prompt should reference a pedagogical framework (like PPP or TBL).
3. The action will call the API, parse the structured response, and save it to the database.
LABELS: backend, ai, feature
---
TITLE: Feat(Lessons): Create Public View Page for Shared Links
BODY:
**Goal:** Build a read-only, public-facing page for students to view their lesson plans.
**Key Steps:**
1. Create a public dynamic route, e.g., `/lesson/[lessonId]`.
2. This page should fetch the lesson data based on the ID.
3. Display the lesson content in a clean, well-formatted, read-only view.
4. This page must NOT require authentication.
LABELS: ui, backend, lessons, feature
---
TITLE: Feat(Lessons): Server Action to Edit/Delete a Lesson
BODY:
**Goal:** Allow tutors to modify or remove generated lesson plans.
**Key Steps:**
1. Implement a server action for deleting a lesson record from the database.
2. For editing, the simplest MVP is to allow editing the text content of a lesson. Create a server action that updates the lesson's content field in the database.
3. The UI should be a simple form with a textarea pre-filled with the lesson content.
LABELS: backend, lessons, feature