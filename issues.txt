// ==========================================
// COMPLETED ISSUES - AUTHENTICATION SYSTEM
// ==========================================

COMPLETED ✅ - TITLE: Setup: Integrate Prisma and Connect to Database
COMPLETED ✅ - TITLE: Feat(Auth): Configure Next-Auth with Prisma Adapter
COMPLETED ✅ - TITLE: Feat(Auth): Implement Session & Protected Middleware
COMPLETED ✅ - TITLE: UI(Auth): Create Login and Signup Pages
COMPLETED ✅ - TITLE: Feat(Auth): Create Server Actions for Signup/Login
COMPLETED ✅ - TITLE: Feat(Auth): Add Google OAuth Provider
COMPLETED ✅ - TITLE: Fix(Auth): Resolve OAuth Account Linking Issues
COMPLETED ✅ - TITLE: Security: Implement Enterprise-Grade Authentication
COMPLETED ✅ - TITLE: Cleanup: Remove Debug Logging from Authentication System

// ==========================================
// CURRENT PRIORITY - SETTINGS & ENHANCED AUTH
// ==========================================

TITLE: Feat(Auth): Implement Password Reset Flow with Industry Standards
BODY:
**Goal:** Add secure password reset functionality following security best practices.
**Key Steps:**
1. Create password reset token model in Prisma schema with expiration
2. Build `/forgot-password` page with email input form
3. Create server action to generate secure reset tokens (crypto.randomBytes)
4. Implement email sending service (Nodemailer/Resend) with reset links
5. Create `/reset-password/[token]` page to handle password updates
6. Add token validation, expiration checks, and secure password hashing
7. Include rate limiting to prevent abuse (max 3 requests per hour)
8. Add proper error handling and user feedback
**Security Requirements:**
- Tokens expire after 1 hour
- Single-use tokens (invalidated after use)
- Secure random token generation (32+ bytes)
- Rate limiting on reset requests
- No user enumeration (same response for valid/invalid emails)
LABELS: auth, security, feature, industry-standard

TITLE: Feat(Settings): Create Tutor Settings/Profile Management Page
BODY:
**Goal:** Build comprehensive settings page for tutor profile management.
**Key Steps:**
1. Create `/dashboard/settings` route and page
2. Implement tabbed interface: Profile, Security, Account Linking
3. **Profile Tab:**
   - Update display name, email, profile picture
   - Change username (unique validation)
   - Bio/description field for tutor profile
4. **Security Tab:**
   - Change password (for credential users)
   - Set password (for OAuth-only users)
   - Two-factor authentication setup (future)
   - Active sessions management
5. **Account Linking Tab:**
   - Connect/disconnect Google account
   - Show linked providers
   - Account merge functionality
6. Form validation with proper error handling
7. Success/error toast notifications
8. Responsive design for mobile/desktop
LABELS: ui, settings, profile, feature

TITLE: Feat(Auth): Account Linking & Provider Management
BODY:
**Goal:** Allow users to link/unlink authentication providers (Google + email/password).
**Dependencies:** Settings page
**Key Steps:**
1. Extend User model to track authentication methods
2. Create server actions for:
   - Linking Google account to existing email/password account
   - Setting password for OAuth-only users
   - Unlinking providers (with safety checks)
3. Add provider status indicators in settings
4. Implement account merge logic for duplicate emails
5. Add security confirmations for account changes
6. Prevent users from removing their only authentication method
**Security Features:**
- Email verification for new email addresses
- Password confirmation for sensitive changes
- Audit log of account modifications
LABELS: auth, security, feature, industry-standard

TITLE: Feat(Email): Setup Transactional Email Service
BODY:
**Goal:** Implement reliable email service for password resets and notifications.
**Key Steps:**
1. Choose email provider (Resend/SendGrid/Nodemailer+SMTP)
2. Set up email templates for:
   - Password reset emails
   - Email verification
   - Account linking confirmations
   - Security notifications
3. Configure environment variables for email service
4. Create reusable email utility functions
5. Add email queue for reliability (future: Redis/Bull)
6. Implement email delivery tracking and error handling
**Note:** Can be implemented locally with development SMTP or email service API keys
LABELS: email, infrastructure, feature

// ==========================================
// EXISTING ISSUES - STUDENTS & LESSONS
// ==========================================
**Key Steps:**
1. Create a `signup` server action that takes form data, hashes the password (using `bcrypt`), and creates a new user in the database via Prisma.
2. Create a `login` server action that uses Next-Auth's `signIn` function with the "credentials" provider.
3. Hook up the forms on the `/signup` and `/login` pages to call these server actions on submit.
4. Implement basic error handling and redirects upon success/failure.
LABELS: auth, backend, feature
---
TITLE: UI(Dashboard): Create Main Dashboard Layout
BODY:
**Goal:** Build the main authenticated application shell.
**Key Steps:**
1. Create a new layout file for the `/dashboard` route group.
2. This layout should include a persistent sidebar for navigation and a main content area.
3. The sidebar should contain links (placeholders for now) for "Dashboard", "Students", and "Settings".
4. Include a user profile/logout button in the sidebar or a top header.
5. This layout must be protected by the middleware from Issue #5.
LABELS: ui, feature
---
TITLE: UI(Students): Create "Add Student" Page and Form
BODY:
**Goal:** Create the user interface for adding a new student to a tutor's roster.
**Key Steps:**
1. Create a page at `/dashboard/students/new`.
2. Build a form with fields for the student's name, email, language being studied, proficiency level (e.g., A1, A2, B1), and learning goals.
3. Style the form according to the application's theme.
LABELS: ui, students, feature
---
TITLE: Feat(Students): Create Server Action to Add Student
BODY:
**Goal:** Implement the backend logic to save a new student to the database.
**Dependencies:** Issue #9
**Key Steps:**
1. Update the `schema.prisma` file with a `Student` model. Remember to link it to the `User` model (a tutor has many students).
2. Create a server action that accepts the student form data.
3. The action should validate the input and create a new `Student` record in the database using Prisma.
4. After successful creation, it should redirect the user to the main students list page (`/dashboard/students`).
LABELS: backend, students, feature
---
TITLE: Feat(Students): Display List of All Students
BODY:
**Goal:** Create a page where the tutor can see all their students.
**Key Steps:**
1. Create a page at `/dashboard/students`.
2. Fetch the list of students associated with the currently logged-in user from the database.
3. Display the students in a list or card format, showing key information like name and language.
4. Each student item should link to their individual dynamic page (e.g., `/dashboard/students/[studentId]`).
LABELS: ui, backend, students, feature
---
TITLE: Feat(Students): Create Dynamic Page for Student
BODY:
**Goal:** Create a detail page for a single student.
**Key Steps:**
1. Create a dynamic route at `/dashboard/students/[studentId]`.
2. This page should fetch and display all details for the specified student.
3. It should also serve as the hub for viewing that student's generated course outlines and lessons (to be implemented later).
4. Include "Edit" and "Archive" buttons on this page.
LABELS: ui, backend, students, feature
---
TITLE: UI(Students): Create "Edit Student" Page
BODY:
**Goal:** Create the UI for updating an existing student's information.
**Dependencies:** Issue #12
**Key Steps:**
1. Create a dynamic route at `/dashboard/students/[studentId]/edit`.
2. The page should fetch the existing student's data and pre-populate the form fields.
3. The form should be identical to the "Add Student" form but for editing purposes.
LABELS: ui, students, feature
---
TITLE: Feat(Students): Create Server Action to Update Student
BODY:
**Goal:** Implement the backend logic to update a student's record.
**Dependencies:** Issue #13
**Key Steps:**
1. Create a server action that takes the updated form data and the student's ID.
2. The action should validate the data and use `prisma.student.update` to save the changes.
3. Upon success, redirect back to the student's detail page.
LABELS: backend, students, feature
---
TITLE: Feat(Students): Create Server Action to Archive Student
BODY:
**Goal:** Implement logic to soft-delete or archive a student.
**Key Steps:**
1. Add an `isArchived` boolean field (or a `status` enum) to the `Student` model in `schema.prisma`.
2. Create a server action that takes a student's ID.
3. The action will set the `isArchived` flag to `true` instead of deleting the record.
4. Archived students should be filtered out from the main student list by default.
LABELS: backend, students, feature
---
TITLE: UI(Lessons): Display Generated Lessons in Dashboard
BODY:
**Goal:** Build the UI on a student's page to list their generated lessons.
**Key Steps:**
1. On the dynamic student page (`/dashboard/students/[studentId]`), create a section to display course outlines and lessons.
2. Lessons should be displayed in a list, showing the lesson title and generation date.
3. Each lesson should have a button to "View" and a "Share" icon.
4. Include a prominent "Generate New Lesson Plan" button.
LABELS: ui, lessons, ai, feature
---
TITLE: Feat(AI): Generate Course Outlines via Server Action
BODY:
**Goal:** Integrate with the Google Gemini API to generate a 10-lesson course outline.
**Key Steps:**
1. Set up the Google Gemini API client.
2. Create a new server action that takes a student's profile (goals, proficiency) as input.
3. Construct a detailed prompt for the Gemini 1.5 Pro model, asking it to generate a structured 10-lesson course outline in JSON format.
4. The action will call the API, parse the response, and save the outline to the database, linked to the student.
LABELS: backend, ai, feature
---
TITLE: Feat(AI): Generate Detailed Lesson Plans via Server Action
BODY:
**Goal:** Use the Gemini API to expand a course outline topic into a full lesson plan.
**Dependencies:** Issue #17
**Key Steps:**
1. Create a server action that takes a student's profile and a specific lesson topic (from the outline).
2. Construct a complex prompt instructing the AI to generate a detailed lesson plan with specific sections: Warm-Up, Vocabulary, Main Activity, Practice, and Cool-Down. The prompt should reference a pedagogical framework (like PPP or TBL).
3. The action will call the API, parse the structured response, and save it to the database.
LABELS: backend, ai, feature
---
TITLE: Feat(Lessons): Create Public View Page for Shared Links
BODY:
**Goal:** Build a read-only, public-facing page for students to view their lesson plans.
**Key Steps:**
1. Create a public dynamic route, e.g., `/lesson/[lessonId]`.
2. This page should fetch the lesson data based on the ID.
3. Display the lesson content in a clean, well-formatted, read-only view.
4. This page must NOT require authentication.
LABELS: ui, backend, lessons, feature
---
TITLE: Feat(Lessons): Server Action to Edit/Delete a Lesson
BODY:
**Goal:** Allow tutors to modify or remove generated lesson plans.
**Key Steps:**
1. Implement a server action for deleting a lesson record from the database.
2. For editing, the simplest MVP is to allow editing the text content of a lesson. Create a server action that updates the lesson's content field in the database.
3. The UI should be a simple form with a textarea pre-filled with the lesson content.
LABELS: backend, lessons, feature